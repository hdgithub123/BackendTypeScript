import { v4 as uuidv4 } from 'uuid';
import executeTransaction from '../executeTransaction';
import getAutoGeneratedColumns from '../utilities/getAutoGeneratedColumns';

export async function insertObjectsTreeTablesUniqueField(
  tablesData: Array<{
    table: string;
    dataIn: Array<{ [key: string]: any }>;
    uniqueField: string;
    parentField: string;
    childField: string;
  }>
): Promise<{
  data: Array<{
    table: string;
    dataIn: Object[];
    oldData: Object[];
    parentField: string;
    childField: string;
  }>;
  status: boolean;
  errorCode: string | Object;
}> {

  const resultData: Array<{
    table: string;
    dataIn: Object[];
    oldData: Object[];
    parentField: string;
    childField: string;
  }> = [];


  const { data, status, errorCode } = await executeTransaction(async (connection) => {
    for (const { table, dataIn, uniqueField, parentField, childField } of tablesData) {
      const { allColumns, autoGeneratedFields } = await getAutoGeneratedColumns(connection, table);

      for (const dataInsertRaw of dataIn) {
        const dataInsert = { ...dataInsertRaw }; // clone để không làm thay đổi data gốc

        // Lấy parentId thực tế dựa trên uniqueField (nếu có)
        const parentUniqueValue = dataInsert[parentField];
        let parentId: string | null = null;

        if (parentUniqueValue) {
          const [parentRows] = await connection.execute(
            `SELECT ${childField} FROM ${table} WHERE ${uniqueField} = ?`,
            [parentUniqueValue]
          );
          if ((parentRows as any[]).length === 0) {
            throw {
              message: `Parent with ${uniqueField} = '${parentUniqueValue}' not found` ,
              code: "ER_NO_REFERENCED_ROW_2",
              errno: 1452,
              sqlState: "23000",
            };
          }
            parentId = (parentRows as any[])[0][childField];
          }

          let sqlString = '';

          if (parentId) {
            const [parentRows] = await connection.execute(
              `SELECT * FROM ${table} WHERE ${childField} = ?`,
              [parentId]
            );
            if (parentRows.length === 0) throw new Error(`Parent with id ${parentId} not found`);
            const parentData = parentRows[0];

            const [children] = await connection.execute(
              `SELECT ${childField} FROM ${table} WHERE ${parentField} = ?`,
              [parentId]
            );

            const isLeaf = (children as any[]).length === 0 ? true : false; // Nếu có con thì không phải leaf
            if (!isLeaf) {
              // Trường hợp parent không phải leaf → insert trực tiếp
              let newRowFiltered = Object.fromEntries(
                Object.entries(dataInsert).filter(([key]) => !autoGeneratedFields.includes(key))
              );
              newRowFiltered = { ...newRowFiltered, [parentField]: parentId }; // Giữ lại uniqueField
              sqlString = `INSERT INTO ${table} (${Object.keys(newRowFiltered).map(k => `${k}`).join(', ')})
              VALUES (${Object.keys(newRowFiltered).map(() => '?').join(', ')})`;

              await connection.execute(
                sqlString,
                Object.values(newRowFiltered)
              );
              continue;
            }

            // ✅ Bước 1: update bản ghi hiện tại (child) thành dữ liệu của parent
            const updatedChildFromParent = { ...dataInsert };
            updatedChildFromParent[parentField] = null; // tạm gỡ liên kết

            for (const col of allColumns) {
              const field = col.Field;

              if (field === childField || !autoGeneratedFields.includes(field)) continue;

              if (col.Type.toLowerCase().includes('uuid')) {
                updatedChildFromParent[field] = uuidv4();
              } else if (col.Type.toLowerCase().includes('timestamp')) {
                updatedChildFromParent[field] = new Date(); // hoặc new Date().toISOString() nếu MySQL cần định dạng ISO
              }

              // Bạn có thể mở rộng thêm các kiểu tự sinh khác ở đây nếu cần
            }

            const updateKeys = Object.keys(updatedChildFromParent).filter(k => k !== childField);


            sqlString = `UPDATE ${table} SET ${updateKeys.map(k => `${k} = ?`).join(', ')} WHERE ${childField} = ?`;
            await connection.execute(
              sqlString,
              [...updateKeys.map(k => updatedChildFromParent[k]), parentId]
            );


            // ✅ Bước 2: clone parent và gán ID mới (UUID)
            const parentClone = { ...parentData };

            // Gán UUID mới cho childField
            const newUUID = uuidv4();
            parentClone[childField] = newUUID;
            const parentCloneFiltered = parentClone;

            sqlString = `INSERT INTO ${table} (${Object.keys(parentCloneFiltered).map(k => `${k}`).join(', ')})
                      VALUES (${Object.keys(parentCloneFiltered).map(() => '?').join(', ')})`;

            await connection.execute(
              sqlString,
              Object.values(parentCloneFiltered)
            );



            // ✅ Bước 3: cập nhật child → gán parent mới
            sqlString = `UPDATE ${table} SET ${parentField} = ? WHERE ${childField} = ?`;
            await connection.execute(
              sqlString,
              [newUUID, parentId]

            );

          } else {
            // Trường hợp không có parent → insert bình thường
            const newRow = { ...dataInsert };

            // Nếu childField nằm trong autoGeneratedFields → tạo thủ công nếu là UUID
            if (autoGeneratedFields.includes(childField)) {
              newRow[childField] = uuidv4();
            }

            const newRowFiltered = Object.fromEntries(
              Object.entries(newRow).filter(([key]) => !autoGeneratedFields.includes(key))
            );

            sqlString = `INSERT INTO ${table} (${Object.keys(newRowFiltered).map(k => `${k}`).join(', ')})
            VALUES (${Object.keys(newRowFiltered).map(() => '?').join(', ')})`;
            await connection.execute(
              sqlString,
              Object.values(newRowFiltered)
            );
          }
        }
      }

      // return { data: null, status: true, errorCode: {} };
    });

      // Gán resultData = tablesData và thêm oldData là mảng rỗng
  tablesData.forEach(({ table, dataIn, parentField, childField }) => {
    resultData.push({
      table,
      dataIn,
      oldData: [],
      parentField,
      childField
    });
  });

  return { data: resultData, status, errorCode };
}
