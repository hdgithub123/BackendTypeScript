import { v4 as uuidv4 } from 'uuid';
import executeTransaction from '../executeTransaction';

async function getAutoGeneratedColumns(connection: any, table: string): Promise<string[]> {
  const [columns] = await connection.execute(`DESCRIBE ${table}`);
  return (columns as any[])
    .filter(col =>
      col.Extra.includes('auto_increment') ||
      col.Extra.toLowerCase().includes('default_generated') ||
      col.Default?.toLowerCase?.().includes('current_timestamp') ||
      col.Extra.includes('on update CURRENT_TIMESTAMP') ||
      col.Default?.toLowerCase?.().includes('uuid()')
    )
    .map(col => col.Field);
}

export async function insertObjectsTreeTables(
  tablesData: Array<{
    table: string;
    dataIn: Array<{ [key: string]: any }>;
    parentField: string;
    childField: string;
  }>
): Promise<{ data: any; status: boolean; errorCode: string | null }> {
  return await executeTransaction(async (connection) => {
    for (const { table, dataIn, parentField, childField } of tablesData) {
      const autoGeneratedFields = await getAutoGeneratedColumns(connection, table);

      for (const dataInsert of dataIn) {
        const parentId = dataInsert[parentField];
        const currentChildId = dataInsert[childField];
        let sqlString = '';

        if (parentId) {
          const [parentRows] = await connection.execute(
            `SELECT * FROM ${table} WHERE ${childField} = ?`,
            [parentId]
          );
          if (parentRows.length === 0) throw new Error(`Parent with id ${parentId} not found`);
          const parentData = parentRows[0];

          const [children] = await connection.execute(
            `SELECT ${childField} FROM ${table} WHERE ${parentField} = ?`,
            [parentId]
          );

          const isLeaf = (children as any[]).length === 0;

          if (!isLeaf) {
            // Trường hợp parent không phải leaf → insert trực tiếp
            const newRowFiltered = Object.fromEntries(
              Object.entries(dataInsert).filter(([key]) => !autoGeneratedFields.includes(key))
            );

            sqlString = `INSERT INTO ${table} (${Object.keys(newRowFiltered).map(k => `${k}`).join(', ')})
              VALUES (${Object.keys(newRowFiltered).map(() => '?').join(', ')})`;

            console.log("sqlString1", sqlString);
            await connection.execute(
              sqlString,
              Object.values(newRowFiltered)
            );
            continue;
          }

          // ✅ Bước 1: update bản ghi hiện tại (child) thành dữ liệu của parent
          const updatedChildFromParent = { ...dataInsert };
          updatedChildFromParent[parentField] = null; // tạm gỡ liên kết

          const updateKeys = Object.keys(updatedChildFromParent).filter(k =>
            !autoGeneratedFields.includes(k) && k !== childField
          );

          sqlString = `UPDATE ${table} SET ${updateKeys.map(k => `${k} = ?`).join(', ')} WHERE ${childField} = ?`;
          console.log("sqlString2", sqlString);
          console.log("updateKeys", updateKeys);
          console.log("parentId", parentId);
          await connection.execute(
            sqlString,
            [...updateKeys.map(k => updatedChildFromParent[k]), parentId]
          );


          // ✅ Bước 2: clone parent và gán ID mới (UUID)
          const parentClone = { ...parentData };

          // Gán UUID mới cho childField
          const newUUID = uuidv4();
          parentClone[childField] = newUUID;

          // Loại bỏ các field auto-gen (trừ khi là childField vì ta đã tạo UUID)
          const parentCloneFiltered = Object.fromEntries(
            Object.entries(parentClone).filter(([key]) =>
              key === childField || !autoGeneratedFields.includes(key)
            )
          );

          sqlString = `INSERT INTO ${table} (${Object.keys(parentCloneFiltered).map(k => `${k}`).join(', ')})
                      VALUES (${Object.keys(parentCloneFiltered).map(() => '?').join(', ')})`;

          console.log("sqlString3", sqlString);
          console.log("Object.values(parentCloneFiltered)", Object.values(parentCloneFiltered));
          await connection.execute(
            sqlString,
            Object.values(parentCloneFiltered)
          );



          // ✅ Bước 3: cập nhật child → gán parent mới
          sqlString = `UPDATE ${table} SET ${parentField} = ? WHERE ${childField} = ?`;
          console.log("sqlString4", sqlString);
          console.log("newUUID", newUUID);
          console.log("currentChildId", currentChildId);
          await connection.execute(
            sqlString,
            // [newUUID, currentChildId]
            [newUUID, parentId]
            
          );

        } else {
          // Trường hợp không có parent → insert bình thường
          const newRow = { ...dataInsert };

          // Nếu childField nằm trong autoGeneratedFields → tạo thủ công nếu là UUID
          if (autoGeneratedFields.includes(childField)) {
            newRow[childField] = uuidv4();
          }

          const newRowFiltered = Object.fromEntries(
            Object.entries(newRow).filter(([key]) => !autoGeneratedFields.includes(key))
          );

          sqlString = `INSERT INTO ${table} (${Object.keys(newRowFiltered).map(k => `${k}`).join(', ')})
            VALUES (${Object.keys(newRowFiltered).map(() => '?').join(', ')})`;

          console.log("sqlString5", sqlString);
          await connection.execute(
            sqlString,
            Object.values(newRowFiltered)
          );
        }
      }
    }

    return { data: 'Insert tree data completed', status: true, errorCode: null };
  });
}
