import { v4 as uuidv4 } from 'uuid';
import executeTransaction from '../executeTransaction';





async function getAutoGeneratedColumns(connection: any, table: string): Promise<{
  allColumns: Array<{
    Field: string;
    Type: string;
    Default: string | null;
    Extra: string;
  }>;
  autoGeneratedFields: string[];
}> {
  const [columns] = await connection.execute(`DESCRIBE ${table}`);

  const allColumns = (columns as any[]).map(col => ({
    Field: col.Field,
    Type: col.Type,
    Default: col.Default,
    Extra: col.Extra
  }));

  const autoGeneratedFields = allColumns
    .filter(col =>
      col.Extra?.toLowerCase().includes('auto_increment') ||
      col.Extra?.toLowerCase().includes('default_generated') ||
      col.Default?.toLowerCase?.().includes('current_timestamp') ||
      col.Extra?.toLowerCase().includes('on update current_timestamp') ||
      col.Default?.toLowerCase?.().includes('uuid()')
    )
    .map(col => col.Field);

  return { allColumns, autoGeneratedFields };
}



export async function insertObjectsTreeTables(
  tablesData: Array<{
    table: string;
    dataIn: Array<{ [key: string]: any }>;
    parentField: string;
    childField: string;
  }>
): Promise<{ data: any; status: boolean; errorCode: string | null }> {
  return await executeTransaction(async (connection) => {
    for (const { table, dataIn, parentField, childField } of tablesData) {
      const { allColumns, autoGeneratedFields } = await getAutoGeneratedColumns(connection, table);

      for (const dataInsert of dataIn) {
        const parentId = dataInsert[parentField];
        const currentChildId = dataInsert[childField];
        let sqlString = '';

        if (parentId) {
          const [parentRows] = await connection.execute(
            `SELECT * FROM ${table} WHERE ${childField} = ?`,
            [parentId]
          );
          if (parentRows.length === 0) throw new Error(`Parent with id ${parentId} not found`);
          const parentData = parentRows[0];

          const [children] = await connection.execute(
            `SELECT ${childField} FROM ${table} WHERE ${parentField} = ?`,
            [parentId]
          );

          const isLeaf = (children as any[]).length === 0;

          if (!isLeaf) {
            // Trường hợp parent không phải leaf → insert trực tiếp
            const newRowFiltered = Object.fromEntries(
              Object.entries(dataInsert).filter(([key]) => !autoGeneratedFields.includes(key))
            );

            sqlString = `INSERT INTO ${table} (${Object.keys(newRowFiltered).map(k => `${k}`).join(', ')})
              VALUES (${Object.keys(newRowFiltered).map(() => '?').join(', ')})`;

            console.log("sqlString1", sqlString);
            await connection.execute(
              sqlString,
              Object.values(newRowFiltered)
            );
            continue;
          }

          // ✅ Bước 1: update bản ghi hiện tại (child) thành dữ liệu của parent
          const updatedChildFromParent = { ...dataInsert };
          updatedChildFromParent[parentField] = null; // tạm gỡ liên kết

          for (const col of allColumns) {
            const field = col.Field;

            if (field === childField || !autoGeneratedFields.includes(field)) continue;

            if (col.Type.toLowerCase().includes('uuid')) {
              updatedChildFromParent[field] = uuidv4();
            } else if (col.Type.toLowerCase().includes('timestamp')) {
              updatedChildFromParent[field] = new Date(); // hoặc new Date().toISOString() nếu MySQL cần định dạng ISO
            }

            // Bạn có thể mở rộng thêm các kiểu tự sinh khác ở đây nếu cần
          }

          const updateKeys = Object.keys(updatedChildFromParent).filter(k => k !== childField);


          sqlString = `UPDATE ${table} SET ${updateKeys.map(k => `${k} = ?`).join(', ')} WHERE ${childField} = ?`;
          await connection.execute(
            sqlString,
            [...updateKeys.map(k => updatedChildFromParent[k]), parentId]
          );


          // ✅ Bước 2: clone parent và gán ID mới (UUID)
          const parentClone = { ...parentData };

          // Gán UUID mới cho childField
          const newUUID = uuidv4();
          parentClone[childField] = newUUID;
          const parentCloneFiltered = parentClone;

          sqlString = `INSERT INTO ${table} (${Object.keys(parentCloneFiltered).map(k => `${k}`).join(', ')})
                      VALUES (${Object.keys(parentCloneFiltered).map(() => '?').join(', ')})`;

          await connection.execute(
            sqlString,
            Object.values(parentCloneFiltered)
          );



          // ✅ Bước 3: cập nhật child → gán parent mới
          sqlString = `UPDATE ${table} SET ${parentField} = ? WHERE ${childField} = ?`;
          await connection.execute(
            sqlString,
            [newUUID, parentId]

          );

        } else {
          // Trường hợp không có parent → insert bình thường
          const newRow = { ...dataInsert };

          // Nếu childField nằm trong autoGeneratedFields → tạo thủ công nếu là UUID
          if (autoGeneratedFields.includes(childField)) {
            newRow[childField] = uuidv4();
          }

          const newRowFiltered = Object.fromEntries(
            Object.entries(newRow).filter(([key]) => !autoGeneratedFields.includes(key))
          );

          sqlString = `INSERT INTO ${table} (${Object.keys(newRowFiltered).map(k => `${k}`).join(', ')})
            VALUES (${Object.keys(newRowFiltered).map(() => '?').join(', ')})`;
          await connection.execute(
            sqlString,
            Object.values(newRowFiltered)
          );
        }
      }
    }

    return { data: 'Insert tree data completed', status: true, errorCode: null };
  });
}
