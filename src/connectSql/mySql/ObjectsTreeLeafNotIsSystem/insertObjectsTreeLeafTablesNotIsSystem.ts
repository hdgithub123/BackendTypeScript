import { v4 as uuidv4 } from 'uuid';
import executeTransaction from '../executeTransaction';
import getAutoGeneratedColumns from '../utilities/getAutoGeneratedColumns';


export default async function insertObjectsTreeTablesNotIsSystem(
  tablesData: Array<{
    table: string;
    dataIn: Array<{ [key: string]: any }>;
    parentField: string;
    childField: string;
  }>
): Promise<{
  data: Array<{
    table: string;
    dataIn: Object[];
    oldData: Object[];
    parentField: string;
    childField: string;
  }>;
  status: boolean;
  errorCode: string | Object;
}> {


  const resultData: Array<{
    table: string;
    dataIn: Object[];
    oldData: Object[];
    parentField: string;
    childField: string;
  }> = [];

  const { data, status, errorCode } = await executeTransaction(async (connection) => {
    for (const { table, dataIn, parentField, childField } of tablesData) {
      const { allColumns, autoGeneratedFields } = await getAutoGeneratedColumns(connection, table);
      const hasIsSystem = allColumns.some(col => col.Field === 'isSystem');

      for (const dataInsert of dataIn) {
        const parentId = dataInsert[parentField];
        const currentChildId = dataInsert[childField];
        let sqlString = '';

        if (parentId) {
          const [parentRows] = await connection.execute(
            `SELECT * FROM ${table} WHERE ${childField} = ?`,
            [parentId]
          );
          if (parentRows.length === 0) throw { message: `Parent with id ${parentId} not found` };
          const parentData = parentRows[0];

          const [children] = await connection.execute(
            `SELECT ${childField} FROM ${table} WHERE ${parentField} = ?`,
            [parentId]
          );

          const isLeaf = (children as any[]).length === 0 ? true : false; // Nếu có con thì không phải leaf
          if (!isLeaf) {
            const insertData = { ...dataInsert };
            if (hasIsSystem) insertData.isSystem = false;

            // Trường hợp parent không phải leaf → insert trực tiếp
            const newRowFiltered = Object.fromEntries(
              Object.entries(insertData).filter(([key]) => !autoGeneratedFields.includes(key))
            );

            sqlString = `INSERT INTO ${table} (${Object.keys(newRowFiltered).map(k => `${k}`).join(', ')})
              VALUES (${Object.keys(newRowFiltered).map(() => '?').join(', ')})`;

            await connection.execute(
              sqlString,
              Object.values(newRowFiltered)
            );
            continue;
          }

          // ✅ Bước 1: update bản ghi hiện tại (child) thành dữ liệu của parent
          const updatedChildFromParent = { ...dataInsert };
          updatedChildFromParent[parentField] = null; // tạm gỡ liên kết

          for (const col of allColumns) {
            const field = col.Field;

            if (field === childField || !autoGeneratedFields.includes(field)) continue;

            if (col.Type.toLowerCase().includes('uuid')) {
              updatedChildFromParent[field] = uuidv4();
            } else if (col.Type.toLowerCase().includes('timestamp')) {
              updatedChildFromParent[field] = new Date(); // hoặc new Date().toISOString() nếu MySQL cần định dạng ISO
            }

            // Bạn có thể mở rộng thêm các kiểu tự sinh khác ở đây nếu cần
          }

          const updateKeys = Object.keys(updatedChildFromParent).filter(k => k !== childField);


          sqlString = `UPDATE ${table} SET ${updateKeys.map(k => `${k} = ?`).join(', ')} WHERE ${childField} = ?`;
          await connection.execute(
            sqlString,
            [...updateKeys.map(k => updatedChildFromParent[k]), parentId]
          );


          // ✅ Bước 2: clone parent và gán ID mới (UUID)
          const parentClone = { ...parentData };

          // Gán UUID mới cho childField
          const newUUID = uuidv4();
          parentClone[childField] = newUUID;
          const parentCloneFiltered = parentClone;

          sqlString = `INSERT INTO ${table} (${Object.keys(parentCloneFiltered).map(k => `${k}`).join(', ')})
                      VALUES (${Object.keys(parentCloneFiltered).map(() => '?').join(', ')})`;

          await connection.execute(
            sqlString,
            Object.values(parentCloneFiltered)
          );



          // ✅ Bước 3: cập nhật child → gán parent mới
          sqlString = `UPDATE ${table} SET ${parentField} = ? WHERE ${childField} = ?`;
          await connection.execute(
            sqlString,
            [newUUID, parentId]

          );

        } else {
          // Trường hợp không có parent → insert bình thường
          const newRow = { ...dataInsert };

          // Nếu childField nằm trong autoGeneratedFields → tạo thủ công nếu là UUID
          if (autoGeneratedFields.includes(childField)) {
            newRow[childField] = uuidv4();
          }

          if (hasIsSystem) {
            newRow['isSystem'] = false;
          }

          const newRowFiltered = Object.fromEntries(
            Object.entries(newRow).filter(([key]) => !autoGeneratedFields.includes(key))
          );

          sqlString = `INSERT INTO ${table} (${Object.keys(newRowFiltered).map(k => `${k}`).join(', ')})
            VALUES (${Object.keys(newRowFiltered).map(() => '?').join(', ')})`;
          await connection.execute(
            sqlString,
            Object.values(newRowFiltered)
          );
        }
      }
    }


  });

  // Gán resultData = tablesData và thêm oldData là mảng rỗng
  tablesData.forEach(({ table, dataIn, parentField, childField }) => {
    resultData.push({
      table,
      dataIn,
      oldData: [],
      parentField,
      childField
    });
  });

  return { data: resultData, status, errorCode };
}


