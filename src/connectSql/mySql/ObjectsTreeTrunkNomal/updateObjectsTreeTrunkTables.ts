import executeTransaction from '../executeTransaction';
import getAutoGeneratedColumns from '../utilities/getAutoGeneratedColumns';

export default async function updateObjectsTreeTrunkTables(
  tablesData: Array<{
    table: string;
    dataIn: Array<{ [key: string]: any }>;
    parentField: string;
    childField: string;
  }>
): Promise<{
  data: Array<{
    table: string;
    dataIn: Object[];
    oldData: Object[];
    parentField: string;
    childField: string;
  }>;
  status: boolean;
  errorCode: string | Object;
}> {
  const resultData: Array<{
    table: string;
    dataIn: Object[];
    oldData: Object[];
    parentField: string;
    childField: string;
  }> = [];
  const validDataIn: Object[] = [];
  const collectedOldData: Object[] = [];

  const { status, errorCode } = await executeTransaction(async (connection) => {
    for (const { table, dataIn, parentField, childField } of tablesData) {
      const { allColumns, autoGeneratedFields } = await getAutoGeneratedColumns(connection, table);
      // const hasIsSystem = allColumns.some(col => col.Field === 'isSystem');

      for (const dataUpdate of dataIn) {
        const currentId = dataUpdate[childField];

        // Lấy bản ghi hiện tại
        const [currentRows] = await connection.execute(
          `SELECT * FROM ${table} WHERE ${childField} = ?`,
          [currentId]
        );
        if (currentRows.length === 0) throw { message: `Record with ID ${currentId} not found` };
        const currentRecord = currentRows[0];

        // Chuẩn bị dữ liệu cập nhật
        const updatePayload = Object.fromEntries(
          Object.entries(dataUpdate).filter(([key]) =>
            !autoGeneratedFields.includes(key)
          )
        );

        const updateKeys = Object.keys(updatePayload);
        const sql = `UPDATE ${table} SET ${updateKeys.map(k => `${k} = ?`).join(', ')} WHERE ${childField} = ?`;

        await connection.execute(
          sql,
          [...updateKeys.map(k => updatePayload[k]), currentId]
        );

        validDataIn.push(dataUpdate);

        const cleanedRows = currentRows.map((row: any) => {
          const newRow: any = {};
          for (const key in dataUpdate) {
            if (key in row) {
              newRow[key] = row[key];
            }
          }
          return newRow;
        });

        collectedOldData.push(...cleanedRows);
      }

      resultData.push({
        table,
        dataIn: validDataIn,
        oldData: collectedOldData,
        parentField,
        childField
      });
    }
  });

  return {
    data: resultData,
    status,
    errorCode
  };
}
